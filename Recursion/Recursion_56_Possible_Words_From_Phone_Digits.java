package Recursion;/*
 *
 * https://www.geeksforgeeks.org/problems/possible-words-from-phone-digits-1587115620/1
 *
 * # Possible Words From Phone Digits
 *
 *   Q. You are given a keypad (as shown in the diagram) and an array arr[ ] containing digits, your task is to
 *      list all possible words in any order which can be generated by pressing numbers in arr[] sequentially.
 *
 *      Note: Number 0 and 1 do not map to any letters.
 *
 *      You can return the words in any order, the driver code will print them in sorted order.
 *   Ex.
 *      Input : arr[] = [2, 3]
 *      Output: [ad, ae, af, bd, be, bf, cd, ce, cf]
 *      Explanation: When we press 2 and 3 total 3 x 3 = 9 possible words formed.
 *
 * Constraints:
 *        1 ≤ arr.size() ≤ 9
 *        0 ≤ arr[i] ≤ 9
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class Recursion_56_Possible_Words_From_Phone_Digits {

    /// main Method
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter digits: (at most 9 digits)");
        String[] s = sc.nextLine().split(" ");

        int n = s.length;
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) arr[i] = Integer.parseInt(s[i]);

        // Answer
        ArrayList<String> ans = possibleWords(arr);

        System.out.println("Possible combinations can be formed using " + Arrays.toString(arr) + ": ");
        for (String str : ans) System.out.println(str);
    }

    /// Solution
    static ArrayList<String> possibleWords(int[] arr) {
        // potd.code.hub
        char[][] keyChar = {
                {/* 0 -> no laters */},
                {/* 1 -> . , ? */},
                {'a', 'b', 'c'},
                {'d', 'e', 'f'},
                {'g', 'h', 'i'},
                {'j', 'k', 'l'},
                {'m', 'n', 'o'},
                {'p', 'q', 'r', 's'},
                {'t', 'u', 'v'},
                {'w', 'x', 'y', 'z'}
        };
        ArrayList<String> ans = new ArrayList<>();
        // updating the ans
        getCombinations(0, arr.length, arr, keyChar, ans, new StringBuilder());

        return ans;
    }

    // helper method
    private static void getCombinations(int i, int n, int[] arr, char[][] keyChars, ArrayList<String> ans, StringBuilder s) {
        // skipping invalid elements
        while (i < n && (arr[i] == 0 || arr[i] == 1)) i++;

        // base case
        if (i == n) {
            ans.add(s.toString());
            return;
        }

        // self work
        for (char ch : keyChars[arr[i]]) {
            // use
            s.append(ch);
            // recursive work
            getCombinations(i + 1, n, arr, keyChars, ans, s);
            // backtrack
            s.deleteCharAt(s.length() - 1);
        }
    }
}
